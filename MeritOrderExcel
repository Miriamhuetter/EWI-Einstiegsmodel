#Extensions
using JuMP
using CPLEX
using XLSX, DataFrames

#Rufe die Excelliste "MeritOrder_Excel" und das entsprechende Tabellenblatt ab. Der Datentyp der Tabellenblatt-Inhalte wird ebenfalls definiert
Kraftwerkstyp = DataFrame(XLSX.readtable("MeritOrder_Excel.xlsx", "Kraftwerke")...) .|> string
Leistung = DataFrame(XLSX.readtable("MeritOrder_Excel.xlsx", "Leistung")...) .|> float 
Kosten = DataFrame(XLSX.readtable("MeritOrder_Excel.xlsx", "Kosten")...) .|> float
Nachfrage = DataFrame(XLSX.readtable("MeritOrder_Excel.xlsx", "Nachfrage")...) .|> float

println(Kraftwerkstyp) #Gebe die Tabelle "Kraftwerkstyp" der aufgerufenen Excelliste "MeritOrder_Excel" im Terminal aus
println() #Gebe eine leere Zeile im Terminal aus
println(Leistung) #Gebe die Tabelle "Leistung" der aufgerufenen Excelliste "MeritOrder_Excel" im Terminal aus
println()
println(Kosten)
println()
println(Nachfrage)
println()

println("Size of Leistungs-Matrix: ", size(Kraftwerkstyp)) #Gebe die Größe der Tabelle Kraftwerkstyp aus -> n wird anschließend für die definition Range verwendet
n_kraft, m_kraft = size(Kraftwerkstyp) #n Anzahl der Kraftwerkskategorien (Anzahl an Zeilen)
n_zeit, m_zeit = size(Nachfrage)

k = Array(Kraftwerkstyp)[:,1]
t = Array(Nachfrage)[:,1]
cost = Array(Kosten)[:,1]
Demand = Array(Nachfrage)[:,2]
capacity = Array(Leistung)[:, end]

cap_matrix = zeros(n_zeit,n_kraft)
cap_matrix[:,1] .= capacity[1]
cap_matrix[:,2] .= capacity[2]
cap_matrix[:,3] .= capacity[3]
cap_matrix[:,4] .= capacity[4]
cap_matrix[:,5] .= capacity[5]
cap_matrix[:,6] .= capacity[6]
cap_matrix[:,7] .= capacity[7]
cap_matrix[:,8] .= capacity[8]
cap_matrix[:,9] .= capacity[9]
cap_matrix[:,10] .= capacity[10]

cap_matrix


model = Model(CPLEX.Optimizer)
@variable(model, x[1:n_zeit, 1:n_kraft] >= 0) #Anzahl der Variablen = Anzahl der Kraftwerkskategorien
@objective(model, Min, sum(cost[k] * x[t, k] for t in 1:n_zeit, k in 1:n_kraft))
@constraint(model, c1, sum(x[:,k] for k in 1:n_kraft) .== Demand[1:end])
@constraint(model, c2, x[:,:] .<= cap_matrix)

print(model)
optimize!(model)
@show value.(x)
@show objective_value(model) 

x[:,1] <= 

x_results = Array{Float64}[] #Erstelle eine leere Liste für die Ergebnisse mit Datentyp Float64
    
    for D in Array(Nachfrage)[:,2] #Betrachtung zu unterschiedlichen Zeitpunkten mit unterschiedlicher Nachfrage (siehe Tabellenblatt in Excel)
        Werte, objective = meritOrder(D) #Aufteilen des Return Befehls in Werte (x Variablen) und objective (=Objektive Value und Shadow price)
        push!(x_results, Werte) #Die Ergebnisse "Werte" werden in die zuvor erstellte Liste übertragen ohne objective_value und shadow_price
    end
x_results #Die Ergebnisliste wird ausgegeben

Kraftwerkeinsatz = transpose(reduce(hcat, x_results)) #Änderung der x_results in ein Matrix Format

Ueberschriften = Kraftwerkstyp.Kraftwerkstyp #Umwandlung von Kraftwerkstyp als Matrix (Aus Exceltabelle) in einen Vector

MO_Ergebnisse = DataFrame(Kraftwerkeinsatz, Ueberschriften) #Ausgabe der Ergebnisse x_results mit Verbindung zu den Überschriften als Tabelle 

#Ergebnisse in Excel exportieren
XLSX.writetable("Ergebnisse.xlsx", MO_Ergebnisse) 

#Zeitkomponente einfügen
a = 1 
#for Schleife in function einbauen
#Matching Brennstoffkosten zu Kraftwerkstyp
#Variablenanzeiger VS
