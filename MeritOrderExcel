#Extensions
using JuMP
using CPLEX
using XLSX, DataFrames

#Rufe die Excelliste "MeritOrder_Excel" und das entsprechende Tabellenblatt ab. Der Datentyp der Tabellenblatt-Inhalte wird ebenfalls definiert
Kraftwerkstyp = DataFrame(XLSX.readtable("MeritOrder_Excel.xlsx", "Kraftwerke")...) .|> string
Leistung = DataFrame(XLSX.readtable("MeritOrder_Excel.xlsx", "Leistung")...) .|> float 
Kosten = DataFrame(XLSX.readtable("MeritOrder_Excel.xlsx", "Kosten")...) .|> float
Nachfrage = DataFrame(XLSX.readtable("MeritOrder_Excel.xlsx", "Nachfrage")...) .|> float

println(Kraftwerkstyp) #Gebe die Tabelle "Kraftwerkstyp" der aufgerufenen Excelliste "MeritOrder_Excel" im Terminal aus
println() #Gebe eine leere Zeile im Terminal aus
println(Leistung) #Gebe die Tabelle "Leistung" der aufgerufenen Excelliste "MeritOrder_Excel" im Terminal aus
println()
println(Kosten)
println()
println(Nachfrage)
println()

println("Size of Leistungs-Matrix: ", size(Kraftwerkstyp)) #Gebe die Größe der Tabelle Kraftwerkstyp aus -> n wird anschließend für die definition Range verwendet
n, m = size(Kraftwerkstyp) #n Anzahl der Kraftwerkskategorien (Anzahl an Zeilen)

function meritOrder(D) #Name der Funktion in Abhängigkeit von D=Demand
    model = Model(CPLEX.Optimizer)

    @variable(model, x[1:n] >= 0) #Anzahl der Variablen = Anzahl der Kraftwerkskategorien
    @constraint(model, c1, sum(x) == D) #Nebenbedingung 1: Summe der verwendeten Kraftwerkskapazität muss gleich dem Bedarf sein
    @constraint(model, c2, x .<= Array(Leistung)[:,end]) #Nebenbedingung 2: Die eingesetzte Kraftwerksleistung des Kraftwerks x, darf dessen installierte Leistung nicht überschreiten
    @objective(model, Min, Array(Kosten)[:,end]'*x) #Zielfunktion: Kosten sollen minimiert werden

    print(model)
    optimize!(model)

    return @show value.(x), @show objective_value(model), @show shadow_price(c1) #Zeige die eingesetzten Kraftwerkskapazität je Kraftwerkskategorie, zeige die Gesamtkosten der Zielfunktion, zeige den Strompreis
end


x_results = Array{Float64}[] #Erstelle eine leere Liste für die Ergebnisse mit Datentyp Float64
    
    for D in Array(Nachfrage)[:,end] #Betrachtung zu unterschiedlichen Zeitpunkten mit unterschiedlicher Nachfrage (siehe Tabellenblatt in Excel)
        Werte, objective = meritOrder(D) #Aufteilen des Return Befehls in Werte (x Variablen) und objective (=Objektive Value und Shadow price)
        push!(x_results, Werte) #Die Ergebnisse "Werte" werden in die zuvor erstellte Liste übertragen ohne objective_value und shadow_price
    end
x_results #Die Ergebnisliste wird ausgegeben

Kraftwerkeinsatz = transpose(reduce(hcat, x_results)) #Änderung der x_results in ein Matrix Format

Ueberschriften = Kraftwerkstyp.Kraftwerkstyp #Umwandlung von Kraftwerkstyp als Matrix (Aus Exceltabelle) in einen Vector

MO_Ergebnisse = DataFrame(Kraftwerkeinsatz, Ueberschriften) #Ausgabe der Ergebnisse x_results mit Verbindung zu den Überschriften als Tabelle 

#Ergebnisse in Excel exportieren
XLSX.writetable("Ergebnisse.xlsx", MO_Ergebnisse) 

#Zeitkomponente einfügen
a = 1 
#for Schleife in function einbauen
#Matching Brennstoffkosten zu Kraftwerkstyp
#Variablenanzeiger VS
