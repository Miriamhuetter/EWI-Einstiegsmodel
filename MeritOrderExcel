#Extensions
using JuMP
using CPLEX
using XLSX, DataFrames

#Rufe die Excelliste "MeritOrder_Excel" und das entsprechende Tabellenblatt ab. Der Datentyp der Tabellenblatt-Inhalte wird ebenfalls definiert
Kraftwerkstyp = DataFrame(XLSX.readtable("MeritOrder_Excel.xlsx", "Kraftwerke")...) .|> string
Kapazität = DataFrame(XLSX.readtable("MeritOrder_Excel.xlsx", "Kapazität")...) .|> float 
Kosten = DataFrame(XLSX.readtable("MeritOrder_Excel.xlsx", "Kosten")...) .|> float
Nachfrage = DataFrame(XLSX.readtable("MeritOrder_Excel.xlsx", "Nachfrage")...) .|> float

#Größe der Excel-Tabellen Kraftwerke und Nachfrage - Anzahl Kraftwerkstypen und Anzahl Stunden (Anzahl Zeilen der Tabellen) werden später benötigt
n_kraft, m_kraft = size(Kraftwerkstyp) 
n_zeit, m_zeit = size(Nachfrage)

#Umwandeln der Excel-Inputs (Grenzkosten, Nachfrage, inst. Kapazität) in eindimensionale Arrays
cost = Array(Kosten)[:,1]
demand = Array(Nachfrage)[:,2]
capacity = Array(Kapazität)[:, end]
header = Kraftwerkstyp.Kraftwerkstyp #Umwandlung von Kraftwerkstyp als Matrix (Aus Exceltabelle) in einen Vector

#Festlegen der Modelleigenschaften mit Variablen, Zielfunktion und Nebenbedingungen
model = Model(CPLEX.Optimizer)
@variable(model, x[1:n_zeit, 1:n_kraft] >= 0) #Definition der Variable x für die Leistung je Kraftwerkskategorie und Stunde; Anzahl der Variablen = Anzahl an Stunden * Anzahl der Kraftwerkskategorien
@objective(model, Min, sum(cost[k] * x[t, k] for t in 1:n_zeit, k in 1:n_kraft)) #Zielfunktion: Multipliziere für jede Kraftwerkskategorie die Grenzkosten mit der eingesetzten Leistung in jeder Stunde -> Minimieren
#constraint über ein set definieren
@constraint(model, c1[t = 1:n_zeit], sum(x[t,:]) == demand[t])
@constraint(model, c2[t = 1:n_zeit, k = 1:n_kraft], x[t, k] .<= capacity[k]) #Die Nebenbedingung 2 ist abhängig von den sets/Mengen "Zeit als Zeilen und den Kraftwerkskategorien als Spalten, ...
# ... die Leistung je Stunde und Kraftwerkskategorie muss kleiner sein als die installierte Kapazität je Kraftwerkskategorie

# Modelloptimierung und Ergebnisausgabe
optimize!(model)
x_results = @show value.(x) #Matrix aller Leistungen
obj_value = @show objective_value(model) #Minimierte Gesamtkosten der Stromerzeugung im gesamten Jahr
el_price = @show shadow_price.(c1) #Strompreis in jeder Stunde des Jahres

#Ausgabe der Ergebnisse als Excel

results = DataFrame(x_results, header)
rm("Ergebnisse.xlsx", force=true) #Lösche die alte, bereits bestehende Excel-Ergebnisliste
XLSX.writetable("Ergebnisse.xlsx", results) #Erstelle eine neue Ergebnisliste

# To Do:
# Matching Brennstoffkosten zu Kraftwerkstyp
    # Emissionsfaktor - fuel
    # Effizienz - Kraftwerkstyp
    # Kraftwerkstyp - fuel

# Erneuerbare einfügen in Supply die availability einbinden, die für fossile immer 1 ist und für EE je Stunde immer variiert
## (Dummy-)Speicher ODER
## Handel zwischen Ländern
# Invest Brounfield, Grienfield -> Investitionskosten einpflegen (Daten von Berit und Philipp)
# Mehrere Modelljahre
# Gedanken machen welches Thema wir vertiefen wollen bis 4.April (14:00-16:00 Uhr)

# Verstehen wie die constraints über verschiedene Sets definiert werden
