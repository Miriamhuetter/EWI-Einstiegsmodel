#Extensions
using JuMP
using CPLEX
using XLSX, DataFrames

#Rufe die Excelliste "MeritOrder_Excel" und das entsprechende Tabellenblatt ab. Der Datentyp der Tabellenblatt-Inhalte wird ebenfalls definiert
Kraftwerkstyp = DataFrame(XLSX.readtable("MeritOrder_Excel.xlsx", "Kraftwerke")...) .|> string
Leistung = DataFrame(XLSX.readtable("MeritOrder_Excel.xlsx", "Leistung")...) .|> float 
Kosten = DataFrame(XLSX.readtable("MeritOrder_Excel.xlsx", "Kosten")...) .|> float
Nachfrage = DataFrame(XLSX.readtable("MeritOrder_Excel.xlsx", "Nachfrage")...) .|> float

println(Kraftwerkstyp) #Gebe die Tabelle "Kraftwerkstyp" der aufgerufenen Excelliste "MeritOrder_Excel" im Terminal aus
println() #Gebe eine leere Zeile im Terminal aus
println(Leistung) #Gebe die Tabelle "Leistung" der aufgerufenen Excelliste "MeritOrder_Excel" im Terminal aus
println()
println(Kosten)
println()
println(Nachfrage)
println()

println("Size of Leistungs-Matrix: ", size(Kraftwerkstyp)) #Gebe die Größe der Tabelle Kraftwerkstyp aus -> n wird anschließend für die definition Range verwendet
n_kraft, m_kraft = size(Kraftwerkstyp) #n Anzahl der Kraftwerkskategorien (Anzahl an Zeilen)
n_zeit, m_zeit = size(Nachfrage)

k = Array(Kraftwerkstyp)[:,1]
t = Array(Nachfrage)[:,1]
cost = Array(Kosten)[:,1]
Demand = Array(Nachfrage)[:,2]
capacity = Array(Leistung)[:, end]

model = Model(CPLEX.Optimizer)
@variable(model, x[1:n_zeit, 1:n_kraft] >= 0) #Anzahl der Variablen = Anzahl der Kraftwerkskategorien
@objective(model, Min, sum(cost[k] * x[t, k] for t in 1:n_zeit, k in 1:n_kraft))
@constraint(model, c1, sum(x[k] for k in 1:n_kraft) == Demand[1])
@constraint(model, c2, x[k] .<= capacity)

for t in 1:n_zeit
    Summe = sum(x[k] for k in 1:n_kraft)
    println(Summe)
end



print(model)
optimize!(model)
@show value.(x)

x_results = Array{Float64}[] #Erstelle eine leere Liste für die Ergebnisse mit Datentyp Float64
    
    for D in Array(Nachfrage)[:,2] #Betrachtung zu unterschiedlichen Zeitpunkten mit unterschiedlicher Nachfrage (siehe Tabellenblatt in Excel)
        Werte, objective = meritOrder(D) #Aufteilen des Return Befehls in Werte (x Variablen) und objective (=Objektive Value und Shadow price)
        push!(x_results, Werte) #Die Ergebnisse "Werte" werden in die zuvor erstellte Liste übertragen ohne objective_value und shadow_price
    end
x_results #Die Ergebnisliste wird ausgegeben

Kraftwerkeinsatz = transpose(reduce(hcat, x_results)) #Änderung der x_results in ein Matrix Format

Ueberschriften = Kraftwerkstyp.Kraftwerkstyp #Umwandlung von Kraftwerkstyp als Matrix (Aus Exceltabelle) in einen Vector

MO_Ergebnisse = DataFrame(Kraftwerkeinsatz, Ueberschriften) #Ausgabe der Ergebnisse x_results mit Verbindung zu den Überschriften als Tabelle 

#Ergebnisse in Excel exportieren
XLSX.writetable("Ergebnisse.xlsx", MO_Ergebnisse) 

#Zeitkomponente einfügen
a = 1 
#for Schleife in function einbauen
#Matching Brennstoffkosten zu Kraftwerkstyp
#Variablenanzeiger VS
