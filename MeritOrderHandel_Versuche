#Extensions
using JuMP
using CPLEX
using XLSX, DataFrames
using Parameters

countries = ["DE","FR","NL"]

#Rufe die Excelliste "MeritOrder_Excel" und das entsprechende Tabellenblatt ab. Der Datentyp der Tabellenblatt-Inhalte wird ebenfalls definiert
Kraftwerke = DataFrame(XLSX.readtable("MeritOrderHandel.xlsx", "Kraftwerke", infer_eltypes=true)...)
Energieträger = DataFrame(XLSX.readtable("MeritOrderHandel.xlsx", "Energieträger", infer_eltypes=true)...)
Nachfrage_alle = DataFrame(XLSX.readtable("MeritOrderHandel.xlsx", "Nachfrage")...) .|> float
CO2_Preis = DataFrame(XLSX.readtable("MeritOrderHandel.xlsx", "CO2-Preis")...) .|> float
Verfügbarkeit = DataFrame(XLSX.readtable("MeritOrderHandel.xlsx", "Verfügbarkeit", infer_eltypes=true)...)

#Größe der Excel-Tabellen Kraftwerke und Nachfrage - Anzahl Kraftwerkstypen und Anzahl Stunden (Anzahl Zeilen der Tabellen) werden später benötigt
n_kraft, m_kraft = size(Kraftwerke) 
n_zeit, n_land = size(Nachfrage_alle)

KraftwerkeDE = filter(row -> row.Land == "DE", Kraftwerke_alle)
KraftwerkeFR = filter(row -> row.Land == "FR", Kraftwerke_alle)

NachfrageDE = Nachfrage_alle[:,"DE"]
NachfrageFR = Nachfrage_alle[:,"FR"]

VerfügbarkeitDE = DataFrame()

for c in countries
    function input(c)

    Kraftwerke = filter(row -> row.Land == c, Kraftwerke_alle)
    #Nachfrage = Nachfrage_alle[:,c]
    
    return Kraftwerke   #, Nachfrage, Nachfrage_alle
    push!(Kraftwerke_DE, Kraftwerke)
    end
end

Kraftwerke_DE


for c in countries

function input(c)

Kraftwerke_*c = filter(row -> row.Land == c, Kraftwerke_alle)
Nachfrage = Nachfrage_alle[:,c]

return Kraftwerke_*c, Nachfrage, Nachfrage_alle
end

Kraftwerke, Nachfrage = input(c)
Kraftwerke
Nachfrage

end


#for c in countries
#    Kraftwerke, Nachfrage = input(c)
#end

#Excelinputs werden weiter verarbeitet, unter anderem um Grenzkosten zu berechnen
function PP(g) #g = Laufvariable durch alle Kraftwerkskategorien hindurch
    A = Kraftwerke[g, :Kraftwerke] #Parameter A wird der Name der Kraftwerkskategorien zugewiesen
    C = Kraftwerke[g, :Kapazität] #Parameter C wird der Wert der installierten Kapazität je Kraftwerkskategorie zugewiesen
    η = Kraftwerke[g, :Wirkungsgrad] #Parameter η wird der Wirkungsgrad je Kraftwerkskategorie zugewiesen
    f = Kraftwerke[g, :Energieträger] #Parameter f wird der Brennstoff je Kraftwerkskategorie zugewiesen
    p_f = Energieträger[1, f] #Preis je Brennstoff und Brennstoff hängt über f von Kraftwerkskategorie ab
    e_f = Energieträger[2, f] #Emissionsfaktor des Brennstoffes
    p_e = CO2_Preis[1, 1] #CO2-Preis
    a_f = Verfügbarkeit[:, f] #Gebe die ganze Spalte je nach Brennstoffart aus


    p_el = (p_f / η) + (e_f / η) * p_e #p_el = Grenzkosten
    return A, p_el, C, a_f #Das Resultat der Funktion PP sollen A und p_el sein
end


costs = [] #Leere Matrix für Grenzkosten wird erstellt
powerplants = [] #Leere Matrix für Kraftwerkskategorien wird erstellt
capacity = [] #Leere Matrix für capacity wird erstellt
avail = [] #Leere Matrix für availability wird erstellt

    for g in 1:n_kraft
        A, p_el, C, a_f = PP(g) #Returnwerte der Funktion PP
        push!(costs, p_el) #Die Returnwerte von p_el sollen in die Matrix costs übergeben werden
        push!(powerplants, A) #Die Returnwerte von A sollen in die Matrix powerplants übergeben werden
        push!(capacity, C) #Die Returnwerte von C sollen in die Matrix capacity übergeben werden
        push!(avail, a_f) #Die Returnwerte von a_f sollen in die Matrix availability übergeben werden
    end

#Konvertieren der Datentypen von den Ausgabematrizen 
convert(Array{Float64, 1}, costs) 
convert(Array{String, 1}, powerplants)
convert(Array{Float64, 1}, capacity)
availability = reduce(hcat, avail) #Die Verfügbarkeit der einzelnen Kraftwerke wird durch reduce und hcat in die richtige Form gebracht (Entspricht der Matrix Form der Ergebnistabelle am Ende)


demand = Array(Nachfrage)
#header = Kraftwerkstyp.Kraftwerkstyp #Umwandlung von Kraftwerkstyp als Matrix (Aus Exceltabelle) in einen Vector

#Festlegen der Modelleigenschaften mit Variablen, Zielfunktion und Nebenbedingungen
model = Model(CPLEX.Optimizer)
@variable(model, x[1:n_zeit, 1:n_kraft, 1:n_land] >= 0) #Definition der Variable x für die Leistung je Kraftwerkskategorie und Stunde; Anzahl der Variablen = Anzahl an Stunden * Anzahl der Kraftwerkskategorien
@objective(model, Min, sum(costs[k, l] * x[t, k, l] for t in 1:n_zeit, k in 1:n_kraft, l in 1:n_land)) #Zielfunktion: Multipliziere für jede Kraftwerkskategorie die Grenzkosten mit der eingesetzten Leistung in jeder Stunde -> Minimieren
#constraint über ein set definieren
@constraint(model, c1[t = 1:n_zeit, l=1:n_land], sum(x[t, :, l]) == demand[t, l])
@constraint(model, c2[t = 1:n_zeit, k = 1:n_kraft, l=1:n_land], x[t, k, l] .<= capacity[k, l]*availability[t, k, l]) #Die Nebenbedingung 2 ist abhängig von den sets/Mengen "Zeit als Zeilen und den Kraftwerkskategorien als Spalten, ...
# ... die Leistung je Stunde und Kraftwerkskategorie muss kleiner sein als die installierte Kapazität je Kraftwerkskategorie multipliziert mit dessen Verfügbarkeit zu der betrachteten Stunde

# Modelloptimierung und Ergebnisausgabe
optimize!(model)
x_results = @show value.(x) #Matrix aller Leistungen
obj_value = @show objective_value(model) #Minimierte Gesamtkosten der Stromerzeugung im gesamten Jahr
el_price = @show shadow_price.(c1) #Strompreis in jeder Stunde des Jahres

#Ausgabe der Ergebnisse als Excel

Excelname = "Ergebnisse"*c*".xlsx"
results = DataFrame(x_results, powerplants)
rm(Excelname, force=true) #Lösche die alte, bereits bestehende Excel-Ergebnisliste
XLSX.writetable(Excelname, results) #Erstelle eine neue Ergebnisliste

end

# To Do:

## (Dummy-)Speicher ODER
## Handel zwischen Ländern
# Invest Brounfield, Greenfield -> Investitionskosten einpflegen (Daten von Berit und Philipp)
# Mehrere Modelljahre
# Gedanken machen welches Thema wir vertiefen wollen bis 4.April (14:00-16:00 Uhr)

# Verstehen wie die constraints über verschiedene Sets definiert werden